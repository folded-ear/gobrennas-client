# This file was generated based on ".graphqlconfig". Do not edit manually.

schema {
    query: Query
    mutation: Mutation
}

interface AccessControlled {
    "The ACL describing grants of access, by the other, to other users."
    grants: [AccessControlEntry!]!
    owner: User!
}

interface Ingredient {
    id: ID!
    labels: [String!]
    name: String!
}

interface Node {
    id: ID!
}

interface Owned {
    "The user who owns this object."
    owner: User!
}

type AccessControlEntry {
    "The level of access the user has been granted."
    level: AccessLevel
    "The user who has been granted access to an AccessControlled object."
    user: User
}

type Favorite implements Node {
    id: ID!
    "The name/title of the object that is a favorite."
    name: String!
    "The ID of the object that is a favorite."
    objectId: ID!
    "The type of object that is a favorite."
    objectType: String!
    owner: User!
}

type FavoriteMutation {
    """

    Add the specified object to the current user's favorites, if not already
    present, and returns the favorite.
    """
    markFavorite(objectId: ID!, objectType: String!): Favorite!
    """

    Remove the specified object from the current user's favorites, and return
    whether any action was required to ensure this.
    """
    removeFavorite(objectId: ID!, objectType: String!): Boolean!
}

type FavoriteQuery {
    "Retrieve the current user's favorites."
    all: [Favorite!]!
    "Retrieve the current user's favorite of the specified object, if exists."
    byObject(objectId: ID!, objectType: String!): Favorite
    "Retrieve the current user's for the specified object type."
    byType(objectType: String!): [Favorite!]!
}

type IngredientRef {
    ingredient: Ingredient
    preparation: String
    quantity: Quantity
    raw: String!
}

type Label implements Node {
    id: ID!
    "Unique label name."
    name: String!
}

type LabelsQuery {
    all: [Label!]!
}

type LibraryQuery {
    """

    Please ignore; I exist because GraphQL defines the available types as
    those reachable from fields. Since PantryItem is currently only used
    polymorphically (e.g., by `Query`'s `node` field), it will not be included
    in the available types.
    """
    pantryItem: PantryItem
    "Search the recipe library."
    recipes(
        """

        Cursor to find results after. This should be omitted to retrieve the
        first page.
        """
        after: Cursor,
        """

        How many recipes to return in the connection. If not specified, 10
        will be returned.
        """
        first: NonNegativeInt! = 10,
        """

        The textual query to filter results by. Can include simple words, as
        well as quoted phrases.
        """
        query: String = "",
        "The scope to search for recipes within."
        scope: LibrarySearchScope! = MINE
    ): RecipeConnection!
}

type Mutation {
    favorite: FavoriteMutation
    timer: TimerMutation
}

type PageInfo {
    "The last cursor returned in this page's edges."
    endCursor: Cursor
    """

    Whether this connection has a next page, or null if included in the
    result of a backward paging operation.
    """
    hasNextPage: Boolean!
    """

    Whether this connection has a previous page, or null if included in the
    result of a forward paging operation.
    """
    hasPreviousPage: Boolean!
    "The first cursor returned in this page's edges."
    startCursor: Cursor
}

type PantryItem implements Ingredient & Node {
    aisle: String
    id: ID!
    labels: [String!]
    name: String!
    storeOrder: Int
}

type Photo {
    focus: [Float!]
    url: String!
}

type Plan implements AccessControlled & Node & Owned {
    buckets: [PlanBucket]
    grants: [AccessControlEntry!]!
    id: ID!
    name: String!
    owner: User!
}

type PlanBucket {
    date: Date!
    id: ID!
    name: String!
}

"Represents a single item on a plan"
type PlanItem implements Node {
    bucket: PlanBucket
    components: [PlanItem]
    id: ID!
    name: String!
    notes: String
    parent: PlanItem
    preparation: String
    quantity: NonNegativeFloat
    status: TaskStatus!
    subtasks: [PlanItem]
    units: String
}

type Quantity {
    quantity: Float!
    units: UnitOfMeasure
}

type Query {
    favorite: FavoriteQuery
    getCurrentUser: User
    getPlanItem(id: ID!): PlanItem
    getPlans: [Plan]
    labels: LabelsQuery
    library: LibraryQuery
    node(id: ID!): Node
    timer: TimerQuery
}

type Recipe implements Ingredient & Node & Owned {
    calories: Int
    directions: String
    externalUrl: String
    favorite: Boolean!
    id: ID!
    ingredients: [IngredientRef!]!
    labels: [String!]
    name: String!
    owner: User!
    photo: Photo
    totalTime(unit: ChronoUnit = MINUTES): Int
    yield: Int
}

type RecipeConnection {
    edges: [RecipeConnectionEdge!]!
    pageInfo: PageInfo!
}

type RecipeConnectionEdge {
    cursor: Cursor!
    node: Recipe!
}

"Represents a pause-able timer of user-specified length."
type Timer implements AccessControlled & Node & Owned {
    "Whether the timer is complete."
    complete: Boolean!
    "Number of seconds the timer is currently set for."
    duration: PositiveInt!
    "When the timer reached or will reach completion; null if paused."
    endAt: DateTime
    grants: [AccessControlEntry!]!
    id: ID!
    "Number of seconds the timer was originally created for."
    initialDuration: PositiveInt!
    owner: User!
    "Whether the timer is paused."
    paused: Boolean!
    "Number of seconds remaining; negative if already complete."
    remaining: Int!
    "Whether the timer is running."
    running: Boolean!
}

type TimerMutation {
    """

    Add the specified duration to the specified timer, which may not be
    complete, but may be paused.
    """
    addTime(duration: PositiveInt!, id: ID!): Timer!
    "Create a new timer with the specified duration and start it."
    create(duration: PositiveInt!): Timer!
    """

    Ensure the specified timer has been deleted, regardless of its status or
    existence, returning whether any action was taken.
    """
    delete(id: ID!): Boolean!
    "Pause the specified running timer."
    pause(id: ID!): Timer!
    "Resume the specified paused timer."
    resume(id: ID!): Timer!
}

type TimerQuery {
    all: [Timer!]!
    byId(id: ID!): Timer!
}

type UnitOfMeasure implements Node {
    id: ID!
    name: String!
}

type User {
    email: String
    id: ID!
    imageUrl: String
    name: String
    provider: String
}

enum AccessLevel {
    ADMINISTER
    CHANGE
    VIEW
}

enum ChronoUnit {
    HOURS
    MILLIS
    MINUTES
    SECONDS
}

enum LibrarySearchScope {
    EVERYONE
    MINE
}

enum TaskStatus {
    ACQUIRED
    COMPLETED
    DELETED
    NEEDED
}

"The type of a cursor, an opaque string used for walking connections."
scalar Cursor

"An RFC-3339 compliant Full Date Scalar"
scalar Date

"An RFC-3339 compliant DateTime Scalar"
scalar DateTime

"An Float scalar that must be greater than or equal to zero"
scalar NonNegativeFloat

"An Int scalar that must be greater than or equal to zero"
scalar NonNegativeInt

"An Int scalar that must be a positive value"
scalar PositiveInt
