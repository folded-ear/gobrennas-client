# This file was generated. Do not edit manually.

schema {
    query: Query
    mutation: Mutation
}

"Indicates an Input Object is a OneOf Input Object."
directive @oneOf on INPUT_OBJECT

interface AccessControlled {
    "The ACL describing grants of access, by the other, to other users."
    grants: [AccessControlEntry!]!
    owner: User!
}

interface CorePlanItem {
    childCount: NonNegativeInt!
    children: [PlanItem!]!
    descendantCount: NonNegativeInt!
    descendants: [PlanItem!]!
    id: ID!
    name: String!
    plan: Plan!
}

interface Ingredient {
    id: ID!
    labels: [String!]
    name: String!
}

interface Node {
    id: ID!
}

interface Owned {
    "The user who owns this object."
    owner: User!
}

type AccessControlEntry {
    "The level of access the user has been granted."
    level: AccessLevel
    "The user who has been granted access to an AccessControlled object."
    user: User
}

type Favorite implements Node {
    id: ID!
    "The name/title of the object that is a favorite."
    name: String!
    "The ID of the object that is a favorite."
    objectId: ID!
    "The type of object that is a favorite."
    objectType: String!
    owner: User!
}

type FavoriteMutation {
    """

    Add the specified object to the current user's favorites, if not already
    present, and returns the favorite.
    """
    markFavorite(objectId: ID!, objectType: String!): Favorite!
    """

    Remove the specified object from the current user's favorites, and return
    whether any action was required to ensure this.
    """
    removeFavorite(objectId: ID!, objectType: String!): Boolean!
}

type FavoriteQuery {
    "Retrieve the current user's favorites, if any."
    all: [Favorite!]!
    "Retrieve the current user's favorite of the specified object, if exists."
    byObject(objectId: ID!, objectType: String!): Favorite
    "Retrieve the current user's favorites for the specified object type, if any."
    byType(objectType: String!): [Favorite!]!
}

type IngredientRef {
    ingredient: Ingredient
    preparation: String
    quantity: Quantity
    raw: String!
}

type Label implements Node {
    id: ID!
    "Unique label name."
    name: String!
}

type LabelsQuery {
    all: [Label!]!
}

type LibraryMutation {
    createRecipe(cookThis: Boolean, info: IngredientInfo!, photo: Upload): Recipe!
    deleteRecipe(id: ID!): Boolean!
    setRecipePhoto(id: ID!, photo: Upload!): Recipe!
    updateRecipe(id: ID!, info: IngredientInfo!, photo: Upload): Recipe!
}

type LibraryQuery {
    getRecipeById(id: ID!): Recipe
    "Search the recipe library."
    recipes(
        """

        Cursor to find results after. This should be omitted to retrieve the
        first page.
        """
        after: Cursor,
        """

        How many recipes to return in the connection. If not specified, 10
        will be returned.
        """
        first: NonNegativeInt! = 10,
        "Ingredient(s) to include. Missing/empty means \"all\"."
        ingredients: [ID!]! = [],
        """

        The textual query to filter results by. Can include simple words, as
        well as quoted phrases.
        """
        query: String! = "",
        "The scope to search for recipes within."
        scope: LibrarySearchScope! = MINE
    ): RecipeConnection!
    """

    Recognize quantity, unit, and/or ingredient in a raw ingredient ref (aka
    item) string, and describe that structure. By default, also provide
    suggestions based on partial matches.
    """
    recognizeItem(
        """

        The position of the cursor in the raw string, used to make contextual
        suggestions. If not specified, the end of the raw string is assumed.
        """
        cursor: NonNegativeInt,
        "The raw string to recognize."
        raw: String!
    ): RecognizedItem
}

type Mutation {
    favorite: FavoriteMutation
    library: LibraryMutation
    pantry: PantryMutation
    planner: PlannerMutation
    timer: TimerMutation
}

type PageInfo {
    "The last cursor returned in this page's edges."
    endCursor: Cursor
    """

    Whether this connection has a next page, or null if included in the
    result of a backward paging operation.
    """
    hasNextPage: Boolean!
    """

    Whether this connection has a previous page, or null if included in the
    result of a forward paging operation.
    """
    hasPreviousPage: Boolean!
    "The first cursor returned in this page's edges."
    startCursor: Cursor
}

type PantryItem implements Ingredient & Node {
    "When this pantry item was first used."
    firstUse: DateTime!
    id: ID!
    labels: [String!]
    name: String!
    """

    The relative order this pantry item will be shown on the shopping view.
    The absolute value has no semantic, and may change arbitrarily.
    """
    storeOrder: Int
    """

    Other names this pantry item can be referred to as. E.g., an "apple" item
    may have synonym "pomme".
    """
    synonyms: [String!]
    """

    The number of times this pantry item is used, including synonyms, in both
    library recipes and on a plan.
    """
    useCount: NonNegativeInt!
}

type PantryItemConnection {
    edges: [PantryItemConnectionEdge!]!
    pageInfo: PageInfo!
}

type PantryItemConnectionEdge {
    cursor: Cursor!
    node: PantryItem!
}

type PantryMutation {
    addLabel(id: ID!, label: String!): PantryItem
    addSynonym(id: ID!, synonym: String!): PantryItem
    """

    Combine two or more pantry items, and return the result, after unifying
    synonyms, labels, and references.
    """
    combineItems(ids: [ID!]!): PantryItem
    deleteItem(id: ID!): Boolean!
    removeLabel(id: ID!, label: String!): PantryItem
    removeSynonym(id: ID!, synonym: String!): PantryItem
    renameItem(id: ID!, name: String!): PantryItem
}

type PantryQuery {
    "Search available pantry items."
    search(
        """

        Cursor to find results after. This should be omitted to retrieve the
        first page.
        """
        after: Cursor,
        "How many items to return in the connection."
        first: NonNegativeInt = 25,
        """

        Textual query to filter items by. The exact query operation performed
        is unspecified.
        """
        query: String,
        """

        Field to sort the result by. If omitted, the sort will be stable, but
        is otherwise unspecified.
        """
        sortBy: String,
        "Direction to sort the result, ascending by default."
        sortDir: SortDir = ASC
    ): PantryItemConnection!
}

type Photo {
    focus: [Float!]
    url: String!
}

type Plan implements AccessControlled & CorePlanItem & Node & Owned {
    bucketCount: NonNegativeInt!
    buckets: [PlanBucket!]!
    childCount: NonNegativeInt!
    children: [PlanItem!]!
    descendantCount: NonNegativeInt!
    descendants: [PlanItem!]!
    grants: [AccessControlEntry!]!
    id: ID!
    name: String!
    owner: User!
    "A plan's plan is always itself."
    plan: Plan!
    share: ShareInfo
}

type PlanBucket {
    date: Date
    id: ID!
    name: String
    plan: Plan!
}

"Represents a single item on a plan"
type PlanItem implements CorePlanItem & Node {
    aggregate: PlanItem
    bucket: PlanBucket
    childCount: NonNegativeInt!
    children: [PlanItem!]!
    componentCount: NonNegativeInt!
    components: [PlanItem!]!
    descendantCount: NonNegativeInt!
    descendants: [PlanItem!]!
    id: ID!
    name: String!
    notes: String
    parent: PlanItem
    plan: Plan!
    preparation: String
    quantity: Quantity
    status: PlanItemStatus!
}

type PlannerMutation {
    "Assign a plan item to a bucket (in the same plan)."
    assignBucket(bucketId: ID!, id: ID!): PlanItem!
    "Create a new bucket w/in a plan, with an optional name and date."
    createBucket(date: Date, name: String, planId: ID!): PlanBucket!
    """

    Create a new item under the specified parent (which may be a plan, for
    top-level items), after the specified peer item (null means 'at end'), and with
    the specified name.
    """
    createItem(afterId: ID, name: String!, parentId: ID!): PlanItem!
    "Create a new empty plan."
    createPlan(name: String!): Plan!
    "Delete a bucket from a plan."
    deleteBucket(bucketId: ID!, planId: ID!): Plan!
    "Deletes the grant for a user w/in a plan, if one exists."
    deleteGrant(planId: ID!, userId: ID!): Plan!
    """

    Deletes an item from a plan, and return its former parent (plan or item).
    This operation cascades.
    """
    deleteItem(id: ID!): PlanItem
    "Deletes the given plan, and all its related data."
    deletePlan(id: ID!): Boolean!
    "Create a new plan by duplicating the specified source plan."
    duplicatePlan(name: String!, sourcePlanId: ID!): Plan!
    """

    Move the given items under the given parent, in order, optionally after a
    specific item already under that parent. The parent's info is returned.
    """
    mutateTree(afterId: ID, itemIds: [ID!]!, parentId: ID!): PlanItem!
    "Update the name of the given plan or plan item (but not bucket)."
    rename(id: ID!, name: String!): PlanItem!
    """

    Reorder the item/plan subitems in the same order as the passed list. If
    there are subitems not included in the list, they will not be reordered. If
    an item under a different parent is included in the list, it will be moved
    under this item.
    """
    reorderSubitems(itemIds: [ID!]!, parentId: ID!): PlanItem
    "Set the access level granted to a user w/in a plan."
    setGrant(accessLevel: AccessLevel, planId: ID!, userId: ID!): Plan!
    """

    Sets the status of the given item. This will always return the updated
    item, though it may immediately moved to the trash (in the background).
    """
    setStatus(id: ID!, status: PlanItemStatus!): PlanItem!
    "Update a bucket w/in a plan, by setting or clearing its name and date."
    updateBucket(bucketId: ID!, date: Date, name: String, planId: ID!): PlanBucket!
}

type PlannerQuery {
    planItem(id: ID!): PlanItem!
    plans: [Plan]!
    """

    Retrieve all items on the given plan which have been updated since the
    passed cutoff (expressed in milliseconds since the UNIX epoch).
    """
    updatedSince(cutoff: Long, planId: ID!): [PlanItem!]!
}

type Quantity {
    quantity: Float!
    units: UnitOfMeasure
}

type Query {
    favorite: FavoriteQuery
    getCurrentUser: User
    labels: LabelsQuery
    library: LibraryQuery
    node(id: ID!): Node
    pantry: PantryQuery
    planner: PlannerQuery
    timer: TimerQuery
}

type Recipe implements Ingredient & Node & Owned {
    calories: Int
    directions: String
    externalUrl: String
    favorite: Boolean!
    id: ID!
    ingredients(
        "Ingredient(s) to include. Missing/empty means \"all\"."
        ingredients: [ID!]! = []
    ): [IngredientRef!]!
    labels: [String!]
    name: String!
    owner: User!
    photo: Photo
    """

    All subrecipes. Multiple layers of nested recipes are flattened, and the
    contextual recipe is not included.
    """
    subrecipes: [Recipe!]!
    totalTime(unit: ChronoUnit = MINUTES): Int
    yield: Int
}

type RecipeConnection {
    edges: [RecipeConnectionEdge!]!
    pageInfo: PageInfo!
}

type RecipeConnectionEdge {
    cursor: Cursor!
    node: Recipe!
}

"""

A suggestion for what might come next at the cursor position, along with the
target range of the raw string it would replace.
"""
type RecognitionSuggestion {
    name: String!
    target: RecognizedRange!
}

"The result of recognizing a raw ingredient ref item."
type RecognizedItem {
    "The position of the cursor in the raw string."
    cursor: NonNegativeInt!
    "Recognized ranges within the raw string."
    ranges: [RecognizedRange!]!
    "The raw string which was recognized."
    raw: String!
    """

    Suggestions of what the user might wish to insert at the current cursor
    position. If more than 'count' suggestions are available, the returned
    subset is unspecified, other than pantry items are preferred to recipes.
    """
    suggestions(count: PositiveInt! = 10): [RecognitionSuggestion!]!
}

"""

A recognized quantity in the raw string. The type indicates which of the id
or quantity fields will be non-null, if either.
"""
type RecognizedRange {
    end: NonNegativeInt!
    id: ID
    quantity: NonNegativeFloat
    start: NonNegativeInt!
    type: RecognizedRangeType!
}

type ShareInfo {
    id: ID!
    secret: String!
    slug: String!
}

"Represents a pause-able timer of user-specified length."
type Timer implements AccessControlled & Node & Owned {
    "Whether the timer is complete."
    complete: Boolean!
    "Number of seconds the timer is currently set for."
    duration: PositiveInt!
    "When the timer reached or will reach completion; null if paused."
    endAt: DateTime
    grants: [AccessControlEntry!]!
    id: ID!
    "Number of seconds the timer was originally created for."
    initialDuration: PositiveInt!
    owner: User!
    "Whether the timer is paused."
    paused: Boolean!
    "Number of seconds remaining; negative if already complete."
    remaining: Int!
    "Whether the timer is running."
    running: Boolean!
}

type TimerMutation {
    """

    Add the specified duration to the specified timer, which may not be
    complete, but may be paused.
    """
    addTime(duration: PositiveInt!, id: ID!): Timer!
    "Create a new timer with the specified duration and start it."
    create(duration: PositiveInt!): Timer!
    """

    Ensure the specified timer has been deleted, regardless of its status or
    existence, returning whether any action was taken.
    """
    delete(id: ID!): Boolean!
    "Pause the specified running timer."
    pause(id: ID!): Timer!
    "Resume the specified paused timer."
    resume(id: ID!): Timer!
}

type TimerQuery {
    all: [Timer!]!
    byId(id: ID!): Timer!
}

type UnitOfMeasure implements Node {
    id: ID!
    name: String!
}

type User {
    email: String
    id: ID!
    imageUrl: String
    name: String
    provider: String
}

enum AccessLevel {
    ADMINISTER
    CHANGE
    VIEW
}

enum ChronoUnit {
    HOURS
    MILLIS
    MINUTES
    SECONDS
}

enum LibrarySearchScope {
    EVERYONE
    MINE
}

enum PlanItemStatus {
    ACQUIRED
    COMPLETED
    DELETED
    NEEDED
}

enum RecognizedRangeType {
    ITEM
    NEW_ITEM
    NEW_UNIT
    QUANTITY
    UNIT
    UNKNOWN
}

enum SortDir {
    ASC
    DESC
}

"The type of a cursor, an opaque string used for walking connections."
scalar Cursor

"An RFC-3339 compliant Full Date Scalar"
scalar Date

"An RFC-3339 compliant DateTime Scalar"
scalar DateTime

"A 64-bit signed integer"
scalar Long

"An Float scalar that must be greater than or equal to zero"
scalar NonNegativeFloat

"An Int scalar that must be greater than or equal to zero"
scalar NonNegativeInt

"An Int scalar that must be a positive value"
scalar PositiveInt

"A file part in a multipart request"
scalar Upload

input IngredientInfo {
    calories: Int
    directions: String
    externalUrl: String
    ingredients: [IngredientRefInfo!]
    labels: [String!]
    name: String!
    photoFocus: [Float!]
    storeOrder: Int
    totalTime: Int
    type: String!
    yield: Int
}

input IngredientRefInfo {
    ingredient: String
    ingredientId: Long
    preparation: String
    quantity: Float
    raw: String!
    units: String
    uomId: Long
}
