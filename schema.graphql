# This file was generated. Do not edit manually.

schema {
    query: Query
    mutation: Mutation
}

interface AccessControlled {
    "The ACL describing grants of access, by the other, to other users."
    grants: [AccessControlEntry!]!
    owner: User!
}

interface CorePlanItem {
    childCount: NonNegativeInt!
    children: [PlanItem!]!
    descendantCount: NonNegativeInt!
    descendants: [PlanItem!]!
    id: ID!
    name: String!
    plan: Plan!
}

interface Ingredient {
    id: ID!
    labels: [String!]
    name: String!
}

interface Node {
    id: ID!
}

interface Owned {
    "The user who owns this object."
    owner: User!
}

type AccessControlEntry {
    "The level of access the user has been granted."
    level: AccessLevel
    "The user who has been granted access to an AccessControlled object."
    user: User
}

type Favorite implements Node {
    id: ID!
    "The name/title of the object that is a favorite."
    name: String!
    "The ID of the object that is a favorite."
    objectId: ID!
    "The type of object that is a favorite."
    objectType: String!
    owner: User!
}

type FavoriteMutation {
    """

    Add the specified object to the current user's favorites, if not already
    present, and returns the favorite.
    """
    markFavorite(objectId: ID!, objectType: String!): Favorite!
    """

    Remove the specified object from the current user's favorites, and return
    whether any action was required to ensure this.
    """
    removeFavorite(objectId: ID!, objectType: String!): Boolean!
}

type FavoriteQuery {
    "Retrieve the current user's favorites, if any."
    all: [Favorite!]!
    "Retrieve the current user's favorite of the specified object, if exists."
    byObject(objectId: ID!, objectType: String!): Favorite
    "Retrieve the current user's favorites for the specified object type, if any."
    byType(objectType: String!): [Favorite!]!
}

type IngredientRef {
    ingredient: Ingredient
    preparation: String
    quantity: Quantity
    raw: String!
}

type Label implements Node {
    id: ID!
    "Unique label name."
    name: String!
}

type LabelsQuery {
    all: [Label!]!
}

type LibraryQuery {
    getRecipeById(id: ID!): Recipe
    """

    Please ignore; I exist because GraphQL defines the available types as
    those reachable from fields. Since PantryItem is currently only used
    polymorphically (e.g., by `Query`'s `node` field), it will not be included
    in the available types.
    """
    pantryItem: PantryItem
    "Search the recipe library."
    recipes(
        """

        Cursor to find results after. This should be omitted to retrieve the
        first page.
        """
        after: Cursor,
        """

        How many recipes to return in the connection. If not specified, 10
        will be returned.
        """
        first: NonNegativeInt! = 10,
        """

        The textual query to filter results by. Can include simple words, as
        well as quoted phrases.
        """
        query: String = "",
        "The scope to search for recipes within."
        scope: LibrarySearchScope! = MINE
    ): RecipeConnection!
}

type Mutation {
    favorite: FavoriteMutation
    planner: PlannerMutation
    timer: TimerMutation
}

type PageInfo {
    "The last cursor returned in this page's edges."
    endCursor: Cursor
    """

    Whether this connection has a next page, or null if included in the
    result of a backward paging operation.
    """
    hasNextPage: Boolean!
    """

    Whether this connection has a previous page, or null if included in the
    result of a forward paging operation.
    """
    hasPreviousPage: Boolean!
    "The first cursor returned in this page's edges."
    startCursor: Cursor
}

type PantryItem implements Ingredient & Node {
    aisle: String
    id: ID!
    labels: [String!]
    name: String!
    storeOrder: Int
}

type Photo {
    focus: [Float!]
    url: String!
}

type Plan implements AccessControlled & CorePlanItem & Node & Owned {
    bucketCount: NonNegativeInt!
    buckets: [PlanBucket!]!
    childCount: NonNegativeInt!
    children: [PlanItem!]!
    descendantCount: NonNegativeInt!
    descendants: [PlanItem!]!
    grants: [AccessControlEntry!]!
    id: ID!
    name: String!
    owner: User!
    "A plan's plan is always itself."
    plan: Plan!
    share: ShareInfo
}

type PlanBucket {
    date: Date
    id: ID!
    name: String
    plan: Plan!
}

"Represents a single item on a plan"
type PlanItem implements CorePlanItem & Node {
    aggregate: PlanItem
    bucket: PlanBucket
    childCount: NonNegativeInt!
    children: [PlanItem!]!
    componentCount: NonNegativeInt!
    components: [PlanItem!]!
    descendantCount: NonNegativeInt!
    descendants: [PlanItem!]!
    id: ID!
    name: String!
    notes: String
    parent: PlanItem
    plan: Plan!
    preparation: String
    quantity: Quantity
    status: PlanItemStatus!
}

type PlannerMutation {
    "Assign a plan item to a bucket (in the same plan)."
    assignBucket(bucketId: ID!, id: ID!): PlanItem!
    "Create a new bucket w/in a plan, with an optional name and date."
    createBucket(date: Date, name: String, planId: ID!): PlanBucket!
    """

    Create a new item under the specified parent (which may be a plan, for
    top-level items), after the specified peer item (null means 'at end'), and with
    the specified name.
    """
    createItem(afterId: ID, name: String!, parentId: ID!): PlanItem!
    "Create a new empty plan."
    createPlan(name: String!): Plan!
    "Delete a bucket from a plan."
    deleteBucket(bucketId: ID!, planId: ID!): Plan!
    "Deletes the grant for a user w/in a plan, if one exists."
    deleteGrant(planId: ID!, userId: ID!): Plan!
    """

    Deletes an item from a plan, and return its former parent (plan or item).
    This operation cascades.
    """
    deleteItem(id: ID!): PlanItem
    "Deletes the given plan, and all its related data."
    deletePlan(id: ID!): Boolean
    "Create a new plan by duplicating the specified source plan."
    duplicatePlan(name: String!, sourcePlanId: ID!): Plan!
    """

    Move the given items under the given parent, in order, optionally after a
    specific item already under that parent. The parent's info is returned.
    """
    mutateTree(afterId: ID, itemIds: [ID!]!, parentId: ID!): PlanItem!
    "Update the name of the given plan or plan item (but not bucket)."
    rename(id: ID!, name: String!): PlanItem!
    """

    Reorder the item/plan subitems in the same order as the passed list. If
    there are subitems not included in the list, they will not be reordered. If
    an item under a different parent is included in the list, it will be moved
    under this item.
    """
    reorderSubitems(itemIds: [ID!]!, parentId: ID!): PlanItem
    "Set the access level granted to a user w/in a plan."
    setGrant(accessLevel: AccessLevel, planId: ID!, userId: ID!): Plan!
    """

    Sets the status of the given item. This will always return the updated
    item, though it may immediately moved to the trash (in the background).
    """
    setStatus(id: ID!, status: PlanItemStatus!): PlanItem!
    "Update a bucket w/in a plan, by setting or clearing its name and date."
    updateBucket(bucketId: ID!, date: Date, name: String, planId: ID!): PlanBucket!
}

type PlannerQuery {
    planItem(id: ID!): PlanItem!
    plans: [Plan]!
    """

    Retrieve all items on the given plan which have been updated since the
    passed cutoff (expressed in milliseconds since the UNIX epoch).
    """
    updatedSince(cutoff: Long, planId: ID!): [PlanItem!]!
}

type Quantity {
    quantity: Float!
    units: UnitOfMeasure
}

type Query {
    favorite: FavoriteQuery
    getCurrentUser: User
    labels: LabelsQuery
    library: LibraryQuery
    node(id: ID!): Node
    planner: PlannerQuery
    timer: TimerQuery
}

type Recipe implements Ingredient & Node & Owned {
    calories: Int
    directions: String
    externalUrl: String
    favorite: Boolean!
    id: ID!
    ingredients: [IngredientRef!]!
    labels: [String!]
    name: String!
    owner: User!
    photo: Photo
    """

    All subrecipes. Multiple layers of nested recipes are flattened, and the
    contextual recipe is not included.
    """
    subrecipes: [Recipe!]!
    totalTime(unit: ChronoUnit = MINUTES): Int
    yield: Int
}

type RecipeConnection {
    edges: [RecipeConnectionEdge!]!
    pageInfo: PageInfo!
}

type RecipeConnectionEdge {
    cursor: Cursor!
    node: Recipe!
}

type ShareInfo {
    id: ID!
    secret: String!
    slug: String!
}

"Represents a pause-able timer of user-specified length."
type Timer implements AccessControlled & Node & Owned {
    "Whether the timer is complete."
    complete: Boolean!
    "Number of seconds the timer is currently set for."
    duration: PositiveInt!
    "When the timer reached or will reach completion; null if paused."
    endAt: DateTime
    grants: [AccessControlEntry!]!
    id: ID!
    "Number of seconds the timer was originally created for."
    initialDuration: PositiveInt!
    owner: User!
    "Whether the timer is paused."
    paused: Boolean!
    "Number of seconds remaining; negative if already complete."
    remaining: Int!
    "Whether the timer is running."
    running: Boolean!
}

type TimerMutation {
    """

    Add the specified duration to the specified timer, which may not be
    complete, but may be paused.
    """
    addTime(duration: PositiveInt!, id: ID!): Timer!
    "Create a new timer with the specified duration and start it."
    create(duration: PositiveInt!): Timer!
    """

    Ensure the specified timer has been deleted, regardless of its status or
    existence, returning whether any action was taken.
    """
    delete(id: ID!): Boolean!
    "Pause the specified running timer."
    pause(id: ID!): Timer!
    "Resume the specified paused timer."
    resume(id: ID!): Timer!
}

type TimerQuery {
    all: [Timer!]!
    byId(id: ID!): Timer!
}

type UnitOfMeasure implements Node {
    id: ID!
    name: String!
}

type User {
    email: String
    id: ID!
    imageUrl: String
    name: String
    provider: String
}

enum AccessLevel {
    ADMINISTER
    CHANGE
    VIEW
}

enum ChronoUnit {
    HOURS
    MILLIS
    MINUTES
    SECONDS
}

enum LibrarySearchScope {
    EVERYONE
    MINE
}

enum PlanItemStatus {
    ACQUIRED
    COMPLETED
    DELETED
    NEEDED
}

"The type of a cursor, an opaque string used for walking connections."
scalar Cursor

"An RFC-3339 compliant Full Date Scalar"
scalar Date

"An RFC-3339 compliant DateTime Scalar"
scalar DateTime

"A 64-bit signed integer"
scalar Long

"An Int scalar that must be greater than or equal to zero"
scalar NonNegativeInt

"An Int scalar that must be a positive value"
scalar PositiveInt
